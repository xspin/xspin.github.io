
# 内存池/内存分配器

## 简介

内存池是一种内存管理技术，在编程中有着重要的作用，以下是需要内存池的几个主要原因：
- 提高内存分配效率
  - 减少系统调用开销
  - 快速定位空闲内存块
- 降低内存碎片
  - 减少外部碎片
  - 优化内部碎片
- 便于内存管理和调试
  - 集中化管理
  - 调试便利性
- 适合特定场景需求
  - 实时系统
  - 嵌入式系统

ptmalloc、tcmalloc 和 jemalloc 是三大常用的内存分配库。
ptmalloc 通用性强，是 glibc 的默认选择；tcmalloc 在多线程场景下表现出色，适合多核系统上的多线程程序；jemalloc 则在减少内存碎片和提高内存利用率方面有优势，尤其适用于对内存使用效率要求高的应用。
可以根据应用的特点和需求选择合适的内存分配器。

## ptmalloc

https://github.com/hustfisher/ptmalloc.git

ptmalloc 是 glibc 标准 C 库中默认的内存分配器。它被广泛应用于基于 Linux 的系统中，因为 glibc 是 Linux 系统上最常用的 C 库。

- 通用性：设计目标是为大多数应用场景提供良好的内存分配性能，在一般情况下表现良好，适用于各种类型的应用程序，无论是简单的命令行工具还是复杂的服务器程序。
- 堆管理：采用一种称为 “伙伴系统（buddy system）” 和 “bin 管理” 相结合的机制。它将堆内存划分为不同大小的块，并通过 bins 来管理这些块，以便快速找到合适大小的内存块进行分配。
- 多线程支持：对多线程环境有较好的支持，通过锁机制来保证线程安全。在多线程应用中，虽然锁的使用可能会带来一定的性能开销，但在大多数情况下能提供稳定的内存分配服务。

## tcmalloc

https://github.com/google/tcmalloc

tcmalloc（Thread - Caching Malloc）由 Google 开发，旨在提高多线程应用程序的内存分配性能。它特别适用于在多核系统上运行的多线程程序。

- 线程缓存：tcmalloc 引入了线程本地缓存（Thread - Local Cache，TLC）的概念。每个线程都有自己的小型缓存，用于存储常用大小的内存块。这大大减少了多线程环境下锁的竞争，因为大多数内存分配和释放操作可以在本地缓存中完成，只有当本地缓存耗尽时才需要访问全局堆，从而显著提高了多线程性能。
- 高效的内存回收：它对内存回收和重用进行了优化，能够快速地将释放的内存块重新整合到可用内存池中，减少内存碎片的产生。
- 性能监控：提供了一些性能监控工具，例如可以统计内存分配和释放的次数、内存使用量等信息，方便开发者进行性能调优。

## jemalloc

https://github.com/jemalloc/jemalloc

由 Jason Evans 开发，最初是为 FreeBSD 操作系统设计的，但现在也广泛应用于其他系统，包括 Linux 和 macOS。它旨在提供高性能的内存分配，同时减少内存碎片。

- 减少碎片：采用一种复杂的内存分配算法，能够有效地减少内存碎片的产生。它将内存划分为不同大小的 “arena”，并根据请求的内存大小在合适的 arena 中进行分配，通过这种方式可以更好地利用内存空间，提高内存利用率。
- 可扩展性：在多线程环境下具有良好的可扩展性。它通过使用多个 arena 来避免全局锁的瓶颈，每个 arena 都可以独立地处理内存分配和释放请求，从而提高了多线程应用的性能。
- 低延迟：在处理大量小内存块的分配和释放时，jemalloc 能够提供较低的延迟，这使得它在一些对响应时间敏感的应用场景（如网络服务器、数据库等）中表现出色。

## 比较

<p class="table-caption">内存管理器优缺点对比</p>

内存管理器 | 优点 | 缺点
----|----|----
jemalloc|出色的抗碎片能力;<br>多线程扩展性佳;<br>低延迟| 内存开销略高;<br>学习成本较高
tcmalloc|线程缓存机制高效;<br>性能监控支持好;<br>内存回收优化 | 通用性稍逊;<br>对特定平台依赖
ptmalloc|通用性强;<br>简单易用|多线程性能受限;<br>内存碎片问题


**jemalloc**

- 优点
  - 出色的抗碎片能力：jemalloc 通过精细的内存划分策略，将内存空间分割为多个不同大小的 “arena”，并依据申请内存块的大小在适宜的 arena 中进行分配。这种方式有效减少了内存碎片，提高了内存利用率，在长时间运行且频繁进行内存分配与释放的程序中表现突出，如数据库管理系统、网络服务器等。
  - 多线程扩展性佳：它采用多 arena 设计，每个 arena 独立处理内存分配与释放请求，减少了锁竞争。这使得 jemalloc 在多线程环境下具备良好的扩展性，能够显著提升多线程程序的性能。
  - 低延迟：对于大量小内存块的分配和释放操作，jemalloc 能够保持较低的延迟，这使其适用于对响应时间敏感的应用场景。
- 缺点
  - 内存开销略高：为了实现其高效的内存管理机制，jemalloc 需要维护额外的数据结构，这会带来一定的内存开销。在内存资源极度受限的环境中，可能需要谨慎考虑。
  - 学习成本较高：由于其复杂的内存管理策略，相比一些简单的内存分配器，开发者需要花费更多时间去理解和掌握其特性，以便充分发挥其优势。

**tcmalloc**
- 优点
  - 线程缓存机制高效：tcmalloc 引入了线程本地缓存（TLC），每个线程拥有自己的小型缓存用于存储常用大小的内存块。这极大地减少了多线程环境下的锁竞争，多数内存操作可在本地缓存完成，显著提升了多线程程序的性能，特别适合在多核系统上运行的多线程应用。
  - 性能监控支持好：提供了性能监控工具，能统计内存分配和释放次数、内存使用量等信息，方便开发者进行性能调优，有助于快速定位和解决内存相关的性能问题。
  - 内存回收优化：对内存回收和重用进行了优化，能快速将释放的内存块整合到可用内存池中，减少内存碎片的产生，在多线程频繁分配和释放内存的场景中表现良好。
- 缺点
  - 通用性稍逊：虽然 tcmalloc 在多线程场景表现优异，但在单线程应用或者对多线程性能提升需求不高的程序中，其优势无法充分体现，相比通用的内存分配器，可能存在不必要的开销。
  - 对特定平台依赖：尽管 tcmalloc 可在多种平台使用，但最初是为特定环境（如 Google 的服务器环境）设计，在某些非典型或资源受限平台上，可能无法发挥最佳性能，甚至可能出现兼容性问题。

**ptmalloc**
- 优点
  - 通用性强：作为 glibc 标准 C 库默认的内存分配器，广泛应用于基于 Linux 的系统，适用于各种类型的应用程序，无论是简单的命令行工具还是复杂的大型软件，无需额外配置即可使用，与系统的兼容性好。
  - 简单易用：其接口就是标准 C 库的 malloc、free 等函数，开发者无需学习新的函数接口，上手容易，对于一般的内存分配需求能够很好地满足。
- 缺点
  - 多线程性能受限：在多线程环境下，ptmalloc 通过锁机制保证线程安全，这会导致一定的性能开销。随着线程数量增加，锁竞争加剧，性能会显著下降，相比专门为多线程设计的 tcmalloc 和 jemalloc，在多线程场景下性能劣势明显。
  - 内存碎片问题：在处理复杂的内存分配模式时，容易产生内存碎片，随着程序运行，可能导致内存利用率降低，尤其在长时间运行且频繁进行大小不一的内存分配和释放操作的程序中更为突出。

## 简单的内存池实现

对于有固定大小或者有固定内存上限的需求，可以有更简单的内存池实现，比如预先申请足够的内存，能避免内存碎片和系统调用，提高性能。

下面是一个简单的内存池实现。

@import "assets/mempool.c"

## 参考资料

- https://www.cnblogs.com/cthon/p/10563946.html
- https://blog.csdn.net/mandagod/article/details/123680210
- https://zhuanlan.zhihu.com/p/469269720