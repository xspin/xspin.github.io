<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>五子棋游戏</title>
    <style>
        body {
            background-color: gray;
            justify-content: center;
            text-align: center;
        }
        canvas {
            border: 1px solid #000;
            box-shadow: 3px 3px 5px rgba(0,0,0,0.2);
            background-color: #F9D65B;
        }
        .controls {
            margin: 10px;
            margin-left: 100px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 0 10px;
        }
        #staus {
            /* font-weight: bold; */
            color: red;
            background-color: red;
        }

    </style>
</head>
<body>
    <canvas id="chessboard" width="600" height="600"></canvas>
    <div class="controls">
        <button onclick="resetGame()">新游戏</button>
        <span id="status">黑棋回合</span>
        <button onclick="nextMove()">下一步</button>
    </div>

    <audio id="audioPlayer" controls src="chess_move.mp3" style="display: none;"></audio>

    <script>
        const canvas = document.getElementById('chessboard');
        const ctx = canvas.getContext('2d');
        const GRID_SIZE = 15; // 15x15棋盘
        const CELL_SIZE = canvas.width / (GRID_SIZE + 1);
        let board = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0)); // 0-空 1-黑 2-白
        const humanPlayer = 1;
        const aiPlayer = 2;
        const noPlayer = 0;
        let currentPlayer = humanPlayer; // 当前玩家
        let gameOver = false;
        const audioPlayer = document.getElementById('audioPlayer');
        let dirx = 0;
        let diry = 0;

        function play() {
            audioPlayer.play();
        }

        // 初始化游戏
        function initGame() {
            // 绘制棋盘
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#000';
            
            // 画棋盘线
            for (let i = 0; i < GRID_SIZE; i++) {
                const pos = (i + 1) * CELL_SIZE;
                // 横线
                ctx.beginPath();
                ctx.moveTo(CELL_SIZE, pos);
                ctx.lineTo(canvas.width - CELL_SIZE, pos);
                ctx.stroke();
                // 竖线
                ctx.beginPath();
                ctx.moveTo(pos, CELL_SIZE);
                ctx.lineTo(pos, canvas.height - CELL_SIZE);
                ctx.stroke();
            }

            // 画星位
            drawStar(3, 3);
            drawStar(3, 11);
            drawStar(11, 3);
            drawStar(11, 11);
            drawStar(7, 7);
        }

        // 绘制星位
        function drawStar(x, y) {
            ctx.beginPath();
            ctx.arc((x+1)*CELL_SIZE, (y+1)*CELL_SIZE, 5, 0, Math.PI*2);
            ctx.fillStyle = '#000';
            ctx.fill();
        }

        var lastPos = null;

        // 绘制棋子
        function drawPiece(x, y, player) {
            ctx.beginPath();
            ctx.arc((x+1)*CELL_SIZE, (y+1)*CELL_SIZE, CELL_SIZE*0.4, 0, Math.PI*2);
            ctx.fillStyle = player === 1 ? '#000' : '#fff';
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.stroke();
            if (lastPos) {
                ctx.lineWidth = 2;
                drawNotice(lastPos.x, lastPos.y, '#F9D65B');
            }
            ctx.lineWidth = 1;
            drawNotice(x, y, 'red');
            lastPos = {x:x, y:y};

            play();
        }

        function drawNotice(x, y, color) {
            ctx.beginPath();
            ctx.arc((x+1)*CELL_SIZE, (y+1)*CELL_SIZE, CELL_SIZE*0.5, 0, Math.PI*2);
            ctx.strokeStyle = color;
            ctx.stroke();
        }

        function drawWin(x, y) {
            const player = currentPlayer;
            const color = 'green';
            // 正向检测
            let dx = dirx;
            let dy = diry;
            let i = x + dx, j = y + dy;
            while (i >= 0 && i < GRID_SIZE && j >= 0 && j < GRID_SIZE && 
                    board[i][j] === player) {
                drawNotice(i, j, color);
                i += dx;
                j += dy;
            }

            // 反向检测
            i = x - dx;
            j = y - dy;
            while (i >= 0 && i < GRID_SIZE && j >= 0 && j < GRID_SIZE && 
                    board[i][j] === player) {
                drawNotice(i, j, color);
                i -= dx;
                j -= dy;
            }

        }

        // 落子逻辑
        function placePiece(x, y) {
            if (gameOver || board[x][y] !== 0) return;

            board[x][y] = currentPlayer;
            drawPiece(x, y, currentPlayer);

            if (checkWin(x, y)) {
                gameOver = true;
                const status = `${currentPlayer === 1 ? '（你）黑棋' : '（AI）白棋'}获胜！`;
                document.getElementById('status').textContent = status;
                drawWin(x, y);
                // alert(status);
                return;
            }

            currentPlayer = currentPlayer === 1 ? 2 : 1;
            document.getElementById('status').textContent = 
                `${currentPlayer === 1 ? '黑棋' : '白棋'}回合`;

            // 简单AI（随机落子）
            if (currentPlayer === 2 && !gameOver) {
                setTimeout(aiMove, 500);
            }
        }

        // 简单AI实现
        function aiMove() {
            const move = findBestMove();
            placePiece(move.x, move.y);
        }

        // 胜利检测
        function checkWin(x, y) {
            player = board[x][y];
            const directions = [
                [1, 0],  // 水平
                [0, 1],  // 垂直
                [1, 1],  // 正对角线
                [1, -1]  // 反对角线
            ];

            for (let [dx, dy] of directions) {
                let count = 1;
                dirx = dx;
                diry = dy
                
                // 正向检测
                let i = x + dx, j = y + dy;
                while (i >= 0 && i < GRID_SIZE && j >= 0 && j < GRID_SIZE && 
                       board[i][j] === player) {
                    count++;
                    i += dx;
                    j += dy;
                }

                // 反向检测
                i = x - dx;
                j = y - dy;
                while (i >= 0 && i < GRID_SIZE && j >= 0 && j < GRID_SIZE && 
                       board[i][j] === player) {
                    count++;
                    i -= dx;
                    j -= dy;
                }

                if (count >= 5) return true;
            }
            return false;
        }

        // 重置游戏
        function resetGame() {
            board = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            lastPos = null;
            currentPlayer = 1;
            gameOver = false;
            document.getElementById('status').textContent = '黑棋回合';
            initGame();
        }

        // 点击事件处理
        canvas.addEventListener('click', (e) => {
            if (gameOver) {
                const status = document.getElementById('status').textContent;
                alert(status);
                return;
            }
            if (currentPlayer !== 1 || gameOver) return;

            const rect = canvas.getBoundingClientRect();
            const x = Math.round((e.clientX - rect.left) / CELL_SIZE) - 1;
            const y = Math.round((e.clientY - rect.top) / CELL_SIZE) - 1;

            if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                placePiece(x, y);
            }
        });

        function nextMove() {
            if (gameOver) {
                const status = document.getElementById('status').textContent;
                alert(status);
                return;
            }
            if (currentPlayer != humanPlayer || gameOver) {
                return;
            }
            const move = findBestMove();
            placePiece(move.x, move.y);
        }

        function hasNeighbor(i, j) {
            const k = 2;
            for (let di = i-k; di <= i+k; di++) {
                for (let dj = j-k; dj <= j+k; dj++) {
                    if (di<0 || dj<0 || di>=GRID_SIZE || dj>=GRID_SIZE) {
                        continue;
                    }
                    if (di==i && dj==j) continue;
                    if (board[di][dj]) {
                        return true;
                    }
                }
            }
            return false;
        }

        function getValidMoves() {
            const emptyCells = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (board[i][j] === 0 && hasNeighbor(i, j)) {
                        emptyCells.push({x: i, y: j});
                    }
                }
            }
            return emptyCells;
        }

        function getScore() {
            const player = currentPlayer;
            var score = 0;
            for (let i=0; i<GRID_SIZE; i++) {
                for (let j=0; j<GRID_SIZE; j++) {
                    if (board[i][j] != player) continue;
                    score += getOneScore(i, j);
                }
            }
            return score;
        }

        function getOneScore(x, y) {
            const directions = [
                [1, 0],  // 水平
                [0, 1],  // 垂直
                [1, 1],  // 正对角线
                [1, -1]  // 反对角线
            ];
            const player = currentPlayer;
            let count = 0;

            for (let [dx, dy] of directions) {
                // 正向检测
                let i = x + dx, j = y + dy;
                while (i >= 0 && i < GRID_SIZE && j >= 0 && j < GRID_SIZE && 
                    board[i][j] === player) {
                    count++;
                    i += dx;
                    j += dy;
                }

                // 反向检测
                i = x - dx;
                j = y - dy;
                while (i >= 0 && i < GRID_SIZE && j >= 0 && j < GRID_SIZE && 
                    board[i][j] === player) {
                    count++;
                    i -= dx;
                    j -= dy;
                }
            }
            return count;
        }

        function minimaxMin(alpha, beta, depth, x, y, val) {
            if (checkWin(x, y)) {
                return [Infinity, true];
            }
            const player = opposite(currentPlayer);
            const moves = getValidMoves();
            for (let i in moves)  {
                const move = moves[i];
                board[move.x][move.y] = player;
                if (checkWin(move.x, move.y)) {
                    board[move.x][move.y] = noPlayer;
                    return [-10-depth, false];
                }
                const v = getOneScore(move.x, move.y);
                const score = minimaxMax(alpha, beta, depth-1, move.x, move.y, val+v);
                if (score < beta) {
                    beta = score;
                }
                board[move.x][move.y] = noPlayer;
                if (alpha >= beta) {
                    break;
                }
            }
            return [beta, false];
        }


        function minimaxMax(alpha, beta, depth, x, y, val) {
            if (depth <= 0) {
                return val;
            }
            const player = currentPlayer;
            const moves = getValidMoves();
            for (let i in moves)  {
                const move = moves[i];
                board[move.x][move.y] = player;
                const v = getOneScore(move.x, move.y);
                const ret = minimaxMin(alpha, beta, depth, move.x, move.y, val+v);
                const score = ret[0];
                if (score > alpha) {
                    alpha = score;
                }
                board[move.x][move.y] = 0;
                if (alpha >= beta) {
                    break;
                }
            }
            return alpha;
        }

        function opposite(player) {
            if (player == aiPlayer) {
                return humanPlayer;
            }
            return aiPlayer;
        }

        function findBestMove() {
            const player = currentPlayer;
            const maxDepth = 2;
            var moves = getValidMoves();
            moves = moves.sort(() => Math.random() - 0.5);
            if (moves.length == 0) {
                const x = Math.floor(Math.random() * board.length);
                const y = Math.floor(Math.random() * board.length);
                moves=[{x:x, y:y}];
            }

            var bestMove = moves[0];
            var alpha = -Infinity;
            var beta = Infinity;
            var val = getScore();
            var currentBestScore = alpha;
            var currentBestMove = null;
            for (let i in moves)  {
                const move = moves[i];
                board[move.x][move.y] = player;
                const v = getOneScore(move.x, move.y);
                const ret = minimaxMin(alpha, beta, maxDepth, move.x, move.y, val+v);
                board[move.x][move.y] = 0;
                const score = ret[0];
                const win = ret[1];
                if (v+score > currentBestScore) {
                    currentBestScore = v+score;
                    currentBestMove = move;
                }
                if (score > alpha || win) {
                    alpha = score;
                    bestMove = move;
                }
                if (win) {
                    break;
                }
            }
            const p = player===aiPlayer?"AI":"Human"
            if (alpha < 0) {
                bestMove = currentBestMove;
                console.log(p + " maybe defeat.");
            }
            console.log(p + " best: " + alpha + " (" + bestMove.x + ", " + bestMove.y + ")");
            return bestMove;
        }

        // 启动游戏
        initGame();
    </script>
</body>
</html>